/* tslint:disable */
/* eslint-disable */
/**
 * Bošán - Interní sekce
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v4.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AcLink
 */
export interface AcLink {
    /**
     * 
     * @type {string}
     * @memberof AcLink
     */
    'href': string;
    /**
     * 
     * @type {boolean}
     * @memberof AcLink
     */
    'allowed': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AcLink
     */
    'applicable': boolean;
    /**
     * 
     * @type {string}
     * @memberof AcLink
     */
    'method': string;
}
/**
 * 
 * @export
 * @interface AlbumEditBody
 */
export interface AlbumEditBody {
    /**
     * 
     * @type {string}
     * @memberof AlbumEditBody
     */
    'name'?: string;
    /**
     * 
     * @type {object}
     * @memberof AlbumEditBody
     */
    'description'?: object;
    /**
     * 
     * @type {object}
     * @memberof AlbumEditBody
     */
    'datePublished'?: object;
    /**
     * 
     * @type {object}
     * @memberof AlbumEditBody
     */
    'dateFrom'?: object;
    /**
     * 
     * @type {object}
     * @memberof AlbumEditBody
     */
    'dateTill'?: object;
    /**
     * 
     * @type {object}
     * @memberof AlbumEditBody
     */
    'eventId'?: object;
}
/**
 * 
 * @export
 * @interface AlbumLinks
 */
export interface AlbumLinks {
    /**
     * 
     * @type {AcLink}
     * @memberof AlbumLinks
     */
    'album:read'?: AcLink;
}
/**
 * 
 * @export
 * @interface AlbumResponse
 */
export interface AlbumResponse {
    /**
     * 
     * @type {number}
     * @memberof AlbumResponse
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof AlbumResponse
     */
    'status': string;
    /**
     * 
     * @type {string}
     * @memberof AlbumResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof AlbumResponse
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof AlbumResponse
     */
    'datePublished'?: string;
    /**
     * 
     * @type {string}
     * @memberof AlbumResponse
     */
    'dateFrom'?: string;
    /**
     * 
     * @type {string}
     * @memberof AlbumResponse
     */
    'dateTill'?: string;
    /**
     * 
     * @type {number}
     * @memberof AlbumResponse
     */
    'eventId'?: number;
    /**
     * 
     * @type {EventResponse}
     * @memberof AlbumResponse
     */
    'event'?: EventResponse;
    /**
     * 
     * @type {object}
     * @memberof AlbumResponse
     */
    'photos'?: object;
    /**
     * 
     * @type {AlbumLinks}
     * @memberof AlbumResponse
     */
    '_links'?: AlbumLinks;
}
/**
 * 
 * @export
 * @interface AlbumsListResponse
 */
export interface AlbumsListResponse {
    /**
     * 
     * @type {number}
     * @memberof AlbumsListResponse
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof AlbumsListResponse
     */
    'status': string;
    /**
     * 
     * @type {string}
     * @memberof AlbumsListResponse
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface CPVEventResponse
 */
export interface CPVEventResponse {
    /**
     * 
     * @type {string}
     * @memberof CPVEventResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CPVEventResponse
     */
    'dateFrom': string;
    /**
     * 
     * @type {string}
     * @memberof CPVEventResponse
     */
    'dateTill': string;
    /**
     * 
     * @type {string}
     * @memberof CPVEventResponse
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof CPVEventResponse
     */
    'link'?: string;
}
/**
 * 
 * @export
 * @interface EventAttendeeResponse
 */
export interface EventAttendeeResponse {
    /**
     * 
     * @type {number}
     * @memberof EventAttendeeResponse
     */
    'eventId': number;
    /**
     * 
     * @type {number}
     * @memberof EventAttendeeResponse
     */
    'memberId': number;
    /**
     * 
     * @type {string}
     * @memberof EventAttendeeResponse
     */
    'type': string;
    /**
     * 
     * @type {object}
     * @memberof EventAttendeeResponse
     */
    'event'?: object;
    /**
     * 
     * @type {object}
     * @memberof EventAttendeeResponse
     */
    'member'?: object;
}
/**
 * 
 * @export
 * @interface EventCreateBody
 */
export interface EventCreateBody {
    /**
     * 
     * @type {string}
     * @memberof EventCreateBody
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof EventCreateBody
     */
    'dateFrom': string;
    /**
     * 
     * @type {string}
     * @memberof EventCreateBody
     */
    'dateTill': string;
    /**
     * 
     * @type {string}
     * @memberof EventCreateBody
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface EventResponse
 */
export interface EventResponse {
    /**
     * 
     * @type {number}
     * @memberof EventResponse
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof EventResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof EventResponse
     */
    'status': EventResponseStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof EventResponse
     */
    'dateFrom': string;
    /**
     * 
     * @type {string}
     * @memberof EventResponse
     */
    'dateTill': string;
    /**
     * 
     * @type {boolean}
     * @memberof EventResponse
     */
    'leadersEvent': boolean;
    /**
     * 
     * @type {string}
     * @memberof EventResponse
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventResponse
     */
    'statusNote'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventResponse
     */
    'place'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventResponse
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventResponse
     */
    'timeFrom'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventResponse
     */
    'timeTill'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventResponse
     */
    'meetingPlaceStart'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventResponse
     */
    'meetingPlaceEnd'?: string;
    /**
     * 
     * @type {number}
     * @memberof EventResponse
     */
    'water_km'?: number;
    /**
     * 
     * @type {string}
     * @memberof EventResponse
     */
    'river'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventResponse
     */
    'deletedAt'?: string;
    /**
     * 
     * @type {object}
     * @memberof EventResponse
     */
    'album'?: object;
    /**
     * 
     * @type {object}
     * @memberof EventResponse
     */
    'groups'?: object;
    /**
     * 
     * @type {Array<EventAttendeeResponse>}
     * @memberof EventResponse
     */
    'attendees'?: Array<EventAttendeeResponse>;
    /**
     * 
     * @type {object}
     * @memberof EventResponse
     */
    'expenses'?: object;
    /**
     * 
     * @type {Array<MemberResponse>}
     * @memberof EventResponse
     */
    'leaders'?: Array<MemberResponse>;
    /**
     * 
     * @type {EventResponseLinks}
     * @memberof EventResponse
     */
    '_links': EventResponseLinks;
}

export const EventResponseStatusEnum = {
    Draft: 'draft',
    Pending: 'pending',
    Public: 'public',
    Cancelled: 'cancelled'
} as const;

export type EventResponseStatusEnum = typeof EventResponseStatusEnum[keyof typeof EventResponseStatusEnum];

/**
 * 
 * @export
 * @interface EventResponseLinks
 */
export interface EventResponseLinks {
    /**
     * 
     * @type {AcLink}
     * @memberof EventResponseLinks
     */
    'publishEvent': AcLink;
    /**
     * 
     * @type {AcLink}
     * @memberof EventResponseLinks
     */
    'unpublishEvent': AcLink;
    /**
     * 
     * @type {AcLink}
     * @memberof EventResponseLinks
     */
    'cancelEvent': AcLink;
    /**
     * 
     * @type {AcLink}
     * @memberof EventResponseLinks
     */
    'uncancelEvent': AcLink;
    /**
     * 
     * @type {AcLink}
     * @memberof EventResponseLinks
     */
    'listEventAttendees': AcLink;
    /**
     * 
     * @type {AcLink}
     * @memberof EventResponseLinks
     */
    'updateEvent': AcLink;
    /**
     * 
     * @type {AcLink}
     * @memberof EventResponseLinks
     */
    'getEvent': AcLink;
    /**
     * 
     * @type {AcLink}
     * @memberof EventResponseLinks
     */
    'deleteEvent': AcLink;
    /**
     * 
     * @type {AcLink}
     * @memberof EventResponseLinks
     */
    'rejectEvent': AcLink;
    /**
     * 
     * @type {AcLink}
     * @memberof EventResponseLinks
     */
    'submitEvent': AcLink;
}
/**
 * 
 * @export
 * @interface EventStatusChangeBody
 */
export interface EventStatusChangeBody {
    /**
     * 
     * @type {string}
     * @memberof EventStatusChangeBody
     */
    'statusNote'?: string;
}
/**
 * 
 * @export
 * @interface EventUpdateBody
 */
export interface EventUpdateBody {
    /**
     * 
     * @type {string}
     * @memberof EventUpdateBody
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof EventUpdateBody
     */
    'status': EventUpdateBodyStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof EventUpdateBody
     */
    'dateFrom': string;
    /**
     * 
     * @type {string}
     * @memberof EventUpdateBody
     */
    'dateTill': string;
    /**
     * 
     * @type {boolean}
     * @memberof EventUpdateBody
     */
    'leadersEvent': boolean;
    /**
     * 
     * @type {string}
     * @memberof EventUpdateBody
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventUpdateBody
     */
    'statusNote'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventUpdateBody
     */
    'place'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventUpdateBody
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventUpdateBody
     */
    'timeFrom'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventUpdateBody
     */
    'timeTill'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventUpdateBody
     */
    'meetingPlaceStart'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventUpdateBody
     */
    'meetingPlaceEnd'?: string;
    /**
     * 
     * @type {number}
     * @memberof EventUpdateBody
     */
    'water_km'?: number;
    /**
     * 
     * @type {string}
     * @memberof EventUpdateBody
     */
    'river'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventUpdateBody
     */
    'deletedAt'?: string;
}

export const EventUpdateBodyStatusEnum = {
    Draft: 'draft',
    Pending: 'pending',
    Public: 'public',
    Cancelled: 'cancelled'
} as const;

export type EventUpdateBodyStatusEnum = typeof EventUpdateBodyStatusEnum[keyof typeof EventUpdateBodyStatusEnum];

/**
 * 
 * @export
 * @interface GroupResponse
 */
export interface GroupResponse {
    /**
     * 
     * @type {string}
     * @memberof GroupResponse
     */
    'id': string;
    /**
     * 
     * @type {boolean}
     * @memberof GroupResponse
     */
    'active': boolean;
    /**
     * 
     * @type {string}
     * @memberof GroupResponse
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface LoginCredentialsBody
 */
export interface LoginCredentialsBody {
    /**
     * 
     * @type {string}
     * @memberof LoginCredentialsBody
     */
    'login': string;
    /**
     * 
     * @type {string}
     * @memberof LoginCredentialsBody
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface LoginGoogleBody
 */
export interface LoginGoogleBody {
    /**
     * 
     * @type {string}
     * @memberof LoginGoogleBody
     */
    'token': string;
}
/**
 * 
 * @export
 * @interface LoginLinkBody
 */
export interface LoginLinkBody {
    /**
     * 
     * @type {string}
     * @memberof LoginLinkBody
     */
    'token': string;
}
/**
 * 
 * @export
 * @interface LoginSendLinkBody
 */
export interface LoginSendLinkBody {
    /**
     * 
     * @type {string}
     * @memberof LoginSendLinkBody
     */
    'login': string;
}
/**
 * 
 * @export
 * @interface MemberResponse
 */
export interface MemberResponse {
    /**
     * 
     * @type {number}
     * @memberof MemberResponse
     */
    'id': number;
    /**
     * 
     * @type {object}
     * @memberof MemberResponse
     */
    'groupId': object;
    /**
     * 
     * @type {boolean}
     * @memberof MemberResponse
     */
    'active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof MemberResponse
     */
    'membership'?: MemberResponseMembershipEnum;
    /**
     * 
     * @type {string}
     * @memberof MemberResponse
     */
    'nickname'?: string;
    /**
     * 
     * @type {string}
     * @memberof MemberResponse
     */
    'function'?: string;
    /**
     * 
     * @type {string}
     * @memberof MemberResponse
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof MemberResponse
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof MemberResponse
     */
    'birthday'?: string;
    /**
     * 
     * @type {string}
     * @memberof MemberResponse
     */
    'addressStreet'?: string;
    /**
     * 
     * @type {string}
     * @memberof MemberResponse
     */
    'addressStreetNo'?: string;
    /**
     * 
     * @type {string}
     * @memberof MemberResponse
     */
    'addressCity'?: string;
    /**
     * 
     * @type {string}
     * @memberof MemberResponse
     */
    'addressPostalCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof MemberResponse
     */
    'addressCountry'?: string;
    /**
     * 
     * @type {string}
     * @memberof MemberResponse
     */
    'mobile'?: string;
    /**
     * 
     * @type {string}
     * @memberof MemberResponse
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof MemberResponse
     */
    'role'?: MemberResponseRoleEnum;
    /**
     * 
     * @type {string}
     * @memberof MemberResponse
     */
    'rank'?: MemberResponseRankEnum;
    /**
     * 
     * @type {GroupResponse}
     * @memberof MemberResponse
     */
    'group'?: GroupResponse;
    /**
     * 
     * @type {object}
     * @memberof MemberResponse
     */
    'contacts'?: object;
    /**
     * 
     * @type {object}
     * @memberof MemberResponse
     */
    'achievements'?: object;
}

export const MemberResponseMembershipEnum = {
    Clen: 'clen',
    Neclen: 'neclen',
    Pozastaveno: 'pozastaveno'
} as const;

export type MemberResponseMembershipEnum = typeof MemberResponseMembershipEnum[keyof typeof MemberResponseMembershipEnum];
export const MemberResponseRoleEnum = {
    Clen: 'clen',
    Vedouci: 'vedouci'
} as const;

export type MemberResponseRoleEnum = typeof MemberResponseRoleEnum[keyof typeof MemberResponseRoleEnum];
export const MemberResponseRankEnum = {
    Dite: 'dite',
    Instruktor: 'instruktor',
    Vedouci: 'vedouci'
} as const;

export type MemberResponseRankEnum = typeof MemberResponseRankEnum[keyof typeof MemberResponseRankEnum];

/**
 * 
 * @export
 * @interface PhotoEditBody
 */
export interface PhotoEditBody {
    /**
     * 
     * @type {number}
     * @memberof PhotoEditBody
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof PhotoEditBody
     */
    'albumId'?: number;
    /**
     * 
     * @type {object}
     * @memberof PhotoEditBody
     */
    'album'?: object;
    /**
     * 
     * @type {object}
     * @memberof PhotoEditBody
     */
    'uploadedById'?: object;
    /**
     * 
     * @type {object}
     * @memberof PhotoEditBody
     */
    'uploadedBy'?: object;
    /**
     * 
     * @type {object}
     * @memberof PhotoEditBody
     */
    'faces'?: object;
    /**
     * 
     * @type {object}
     * @memberof PhotoEditBody
     */
    'title'?: object;
    /**
     * 
     * @type {object}
     * @memberof PhotoEditBody
     */
    'name'?: object;
    /**
     * 
     * @type {object}
     * @memberof PhotoEditBody
     */
    'caption'?: object;
    /**
     * 
     * @type {object}
     * @memberof PhotoEditBody
     */
    'width'?: object;
    /**
     * 
     * @type {object}
     * @memberof PhotoEditBody
     */
    'height'?: object;
    /**
     * 
     * @type {object}
     * @memberof PhotoEditBody
     */
    'timestamp'?: object;
    /**
     * 
     * @type {object}
     * @memberof PhotoEditBody
     */
    'tags'?: object;
    /**
     * 
     * @type {object}
     * @memberof PhotoEditBody
     */
    'bg'?: object;
}
/**
 * 
 * @export
 * @interface PhotoResponse
 */
export interface PhotoResponse {
    /**
     * 
     * @type {number}
     * @memberof PhotoResponse
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof PhotoResponse
     */
    'albumId': number;
    /**
     * 
     * @type {object}
     * @memberof PhotoResponse
     */
    'album'?: object;
    /**
     * 
     * @type {object}
     * @memberof PhotoResponse
     */
    'uploadedById'?: object;
    /**
     * 
     * @type {object}
     * @memberof PhotoResponse
     */
    'uploadedBy'?: object;
    /**
     * 
     * @type {object}
     * @memberof PhotoResponse
     */
    'faces'?: object;
    /**
     * 
     * @type {object}
     * @memberof PhotoResponse
     */
    'title'?: object;
    /**
     * 
     * @type {object}
     * @memberof PhotoResponse
     */
    'name'?: object;
    /**
     * 
     * @type {object}
     * @memberof PhotoResponse
     */
    'caption'?: object;
    /**
     * 
     * @type {object}
     * @memberof PhotoResponse
     */
    'width'?: object;
    /**
     * 
     * @type {object}
     * @memberof PhotoResponse
     */
    'height'?: object;
    /**
     * 
     * @type {object}
     * @memberof PhotoResponse
     */
    'timestamp'?: object;
    /**
     * 
     * @type {object}
     * @memberof PhotoResponse
     */
    'tags'?: object;
    /**
     * 
     * @type {object}
     * @memberof PhotoResponse
     */
    'bg'?: object;
}
/**
 * 
 * @export
 * @interface PhotosListResponse
 */
export interface PhotosListResponse {
    /**
     * 
     * @type {number}
     * @memberof PhotosListResponse
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof PhotosListResponse
     */
    'albumId': number;
    /**
     * 
     * @type {object}
     * @memberof PhotosListResponse
     */
    'title'?: object;
    /**
     * 
     * @type {object}
     * @memberof PhotosListResponse
     */
    'name'?: object;
}
/**
 * 
 * @export
 * @interface UserCreateBody
 */
export interface UserCreateBody {
    /**
     * 
     * @type {number}
     * @memberof UserCreateBody
     */
    'memberId'?: number;
    /**
     * 
     * @type {string}
     * @memberof UserCreateBody
     */
    'login'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserCreateBody
     */
    'email'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserCreateBody
     */
    'roles'?: Array<UserCreateBodyRolesEnum>;
}

export const UserCreateBodyRolesEnum = {
    Admin: 'admin',
    Revizor: 'revizor',
    Program: 'program'
} as const;

export type UserCreateBodyRolesEnum = typeof UserCreateBodyRolesEnum[keyof typeof UserCreateBodyRolesEnum];

/**
 * 
 * @export
 * @interface UserResponse
 */
export interface UserResponse {
    /**
     * 
     * @type {number}
     * @memberof UserResponse
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof UserResponse
     */
    'login': string;
    /**
     * 
     * @type {number}
     * @memberof UserResponse
     */
    'memberId'?: number;
    /**
     * 
     * @type {string}
     * @memberof UserResponse
     */
    'password'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserResponse
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserResponse
     */
    'loginCode'?: string;
    /**
     * 
     * @type {ModelDate}
     * @memberof UserResponse
     */
    'loginCodeExp'?: ModelDate;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserResponse
     */
    'roles'?: Array<UserResponseRolesEnum>;
    /**
     * 
     * @type {MemberResponse}
     * @memberof UserResponse
     */
    'member'?: MemberResponse;
    /**
     * 
     * @type {UserResponseLinks}
     * @memberof UserResponse
     */
    '_links': UserResponseLinks;
}

export const UserResponseRolesEnum = {
    Admin: 'admin',
    Revizor: 'revizor',
    Program: 'program'
} as const;

export type UserResponseRolesEnum = typeof UserResponseRolesEnum[keyof typeof UserResponseRolesEnum];

/**
 * 
 * @export
 * @interface UserResponseLinks
 */
export interface UserResponseLinks {
    /**
     * 
     * @type {AcLink}
     * @memberof UserResponseLinks
     */
    'deleteUser': AcLink;
    /**
     * 
     * @type {AcLink}
     * @memberof UserResponseLinks
     */
    'getUser': AcLink;
    /**
     * 
     * @type {AcLink}
     * @memberof UserResponseLinks
     */
    'updateUser': AcLink;
    /**
     * 
     * @type {AcLink}
     * @memberof UserResponseLinks
     */
    'impersonateUser': AcLink;
    /**
     * 
     * @type {AcLink}
     * @memberof UserResponseLinks
     */
    'setUserPassword': AcLink;
}
/**
 * 
 * @export
 * @interface UserSetPasswordBody
 */
export interface UserSetPasswordBody {
    /**
     * 
     * @type {string}
     * @memberof UserSetPasswordBody
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface UserUpdateBody
 */
export interface UserUpdateBody {
    /**
     * 
     * @type {number}
     * @memberof UserUpdateBody
     */
    'memberId'?: number;
    /**
     * 
     * @type {string}
     * @memberof UserUpdateBody
     */
    'login'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserUpdateBody
     */
    'email'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserUpdateBody
     */
    'roles'?: Array<UserUpdateBodyRolesEnum>;
}

export const UserUpdateBodyRolesEnum = {
    Admin: 'admin',
    Revizor: 'revizor',
    Program: 'program'
} as const;

export type UserUpdateBodyRolesEnum = typeof UserUpdateBodyRolesEnum[keyof typeof UserUpdateBodyRolesEnum];


/**
 * AccountApi - axios parameter creator
 * @export
 */
export const AccountApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMe: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/account`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {LoginCredentialsBody} loginCredentialsBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginUsingCredentials: async (loginCredentialsBody: LoginCredentialsBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginCredentialsBody' is not null or undefined
            assertParamExists('loginUsingCredentials', 'loginCredentialsBody', loginCredentialsBody)
            const localVarPath = `/account/login/credentials`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginCredentialsBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {LoginGoogleBody} loginGoogleBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginUsingGoogle: async (loginGoogleBody: LoginGoogleBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginGoogleBody' is not null or undefined
            assertParamExists('loginUsingGoogle', 'loginGoogleBody', loginGoogleBody)
            const localVarPath = `/account/login/google`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginGoogleBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {LoginLinkBody} loginLinkBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginUsingLink: async (loginLinkBody: LoginLinkBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginLinkBody' is not null or undefined
            assertParamExists('loginUsingLink', 'loginLinkBody', loginLinkBody)
            const localVarPath = `/account/login/link`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginLinkBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/account/login/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {LoginSendLinkBody} loginSendLinkBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendLoginLink: async (loginSendLinkBody: LoginSendLinkBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginSendLinkBody' is not null or undefined
            assertParamExists('sendLoginLink', 'loginSendLinkBody', loginSendLinkBody)
            const localVarPath = `/account/login/sendLink`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginSendLinkBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountApi - functional programming interface
 * @export
 */
export const AccountApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMe(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMe(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {LoginCredentialsBody} loginCredentialsBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loginUsingCredentials(loginCredentialsBody: LoginCredentialsBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.loginUsingCredentials(loginCredentialsBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {LoginGoogleBody} loginGoogleBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loginUsingGoogle(loginGoogleBody: LoginGoogleBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.loginUsingGoogle(loginGoogleBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {LoginLinkBody} loginLinkBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loginUsingLink(loginLinkBody: LoginLinkBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.loginUsingLink(loginLinkBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logout(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logout(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {LoginSendLinkBody} loginSendLinkBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendLoginLink(loginSendLinkBody: LoginSendLinkBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendLoginLink(loginSendLinkBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AccountApi - factory interface
 * @export
 */
export const AccountApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMe(options?: any): AxiosPromise<UserResponse> {
            return localVarFp.getMe(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {LoginCredentialsBody} loginCredentialsBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginUsingCredentials(loginCredentialsBody: LoginCredentialsBody, options?: any): AxiosPromise<void> {
            return localVarFp.loginUsingCredentials(loginCredentialsBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {LoginGoogleBody} loginGoogleBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginUsingGoogle(loginGoogleBody: LoginGoogleBody, options?: any): AxiosPromise<void> {
            return localVarFp.loginUsingGoogle(loginGoogleBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {LoginLinkBody} loginLinkBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginUsingLink(loginLinkBody: LoginLinkBody, options?: any): AxiosPromise<void> {
            return localVarFp.loginUsingLink(loginLinkBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout(options?: any): AxiosPromise<void> {
            return localVarFp.logout(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {LoginSendLinkBody} loginSendLinkBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendLoginLink(loginSendLinkBody: LoginSendLinkBody, options?: any): AxiosPromise<void> {
            return localVarFp.sendLoginLink(loginSendLinkBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccountApi - object-oriented interface
 * @export
 * @class AccountApi
 * @extends {BaseAPI}
 */
export class AccountApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public getMe(options?: AxiosRequestConfig) {
        return AccountApiFp(this.configuration).getMe(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {LoginCredentialsBody} loginCredentialsBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public loginUsingCredentials(loginCredentialsBody: LoginCredentialsBody, options?: AxiosRequestConfig) {
        return AccountApiFp(this.configuration).loginUsingCredentials(loginCredentialsBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {LoginGoogleBody} loginGoogleBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public loginUsingGoogle(loginGoogleBody: LoginGoogleBody, options?: AxiosRequestConfig) {
        return AccountApiFp(this.configuration).loginUsingGoogle(loginGoogleBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {LoginLinkBody} loginLinkBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public loginUsingLink(loginLinkBody: LoginLinkBody, options?: AxiosRequestConfig) {
        return AccountApiFp(this.configuration).loginUsingLink(loginLinkBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public logout(options?: AxiosRequestConfig) {
        return AccountApiFp(this.configuration).logout(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {LoginSendLinkBody} loginSendLinkBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public sendLoginLink(loginSendLinkBody: LoginSendLinkBody, options?: AxiosRequestConfig) {
        return AccountApiFp(this.configuration).sendLoginLink(loginSendLinkBody, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EventsApi - axios parameter creator
 * @export
 */
export const EventsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} id 
         * @param {EventStatusChangeBody} eventStatusChangeBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelEvent: async (id: number, eventStatusChangeBody: EventStatusChangeBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('cancelEvent', 'id', id)
            // verify required parameter 'eventStatusChangeBody' is not null or undefined
            assertParamExists('cancelEvent', 'eventStatusChangeBody', eventStatusChangeBody)
            const localVarPath = `/events/{id}/cancel`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(eventStatusChangeBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {EventCreateBody} eventCreateBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEvent: async (eventCreateBody: EventCreateBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventCreateBody' is not null or undefined
            assertParamExists('createEvent', 'eventCreateBody', eventCreateBody)
            const localVarPath = `/events`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(eventCreateBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEvent: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteEvent', 'id', id)
            const localVarPath = `/events/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {number} memberId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEventAttendee: async (id: number, memberId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteEventAttendee', 'id', id)
            // verify required parameter 'memberId' is not null or undefined
            assertParamExists('deleteEventAttendee', 'memberId', memberId)
            const localVarPath = `/events/{id}/attendees/{memberId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"memberId"}}`, encodeURIComponent(String(memberId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCPVEvents: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/events`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvent: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getEvent', 'id', id)
            const localVarPath = `/events/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEventAttendees: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listEventAttendees', 'id', id)
            const localVarPath = `/events/{id}/attendees`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {EventStatusChangeBody} eventStatusChangeBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publishEvent: async (id: number, eventStatusChangeBody: EventStatusChangeBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('publishEvent', 'id', id)
            // verify required parameter 'eventStatusChangeBody' is not null or undefined
            assertParamExists('publishEvent', 'eventStatusChangeBody', eventStatusChangeBody)
            const localVarPath = `/events/{id}/publish`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(eventStatusChangeBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {EventStatusChangeBody} eventStatusChangeBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rejectEvent: async (id: number, eventStatusChangeBody: EventStatusChangeBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('rejectEvent', 'id', id)
            // verify required parameter 'eventStatusChangeBody' is not null or undefined
            assertParamExists('rejectEvent', 'eventStatusChangeBody', eventStatusChangeBody)
            const localVarPath = `/events/{id}/reject`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(eventStatusChangeBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {EventStatusChangeBody} eventStatusChangeBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitEvent: async (id: number, eventStatusChangeBody: EventStatusChangeBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('submitEvent', 'id', id)
            // verify required parameter 'eventStatusChangeBody' is not null or undefined
            assertParamExists('submitEvent', 'eventStatusChangeBody', eventStatusChangeBody)
            const localVarPath = `/events/{id}/submit`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(eventStatusChangeBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {EventStatusChangeBody} eventStatusChangeBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uncancelEvent: async (id: number, eventStatusChangeBody: EventStatusChangeBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('uncancelEvent', 'id', id)
            // verify required parameter 'eventStatusChangeBody' is not null or undefined
            assertParamExists('uncancelEvent', 'eventStatusChangeBody', eventStatusChangeBody)
            const localVarPath = `/events/{id}/uncancel`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(eventStatusChangeBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {EventStatusChangeBody} eventStatusChangeBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unpublishEvent: async (id: number, eventStatusChangeBody: EventStatusChangeBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('unpublishEvent', 'id', id)
            // verify required parameter 'eventStatusChangeBody' is not null or undefined
            assertParamExists('unpublishEvent', 'eventStatusChangeBody', eventStatusChangeBody)
            const localVarPath = `/events/{id}/unpublish`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(eventStatusChangeBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {EventUpdateBody} eventUpdateBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEvent: async (id: number, eventUpdateBody: EventUpdateBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateEvent', 'id', id)
            // verify required parameter 'eventUpdateBody' is not null or undefined
            assertParamExists('updateEvent', 'eventUpdateBody', eventUpdateBody)
            const localVarPath = `/events/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(eventUpdateBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {number} memberId 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEventAttendee: async (id: number, memberId: number, body: object, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateEventAttendee', 'id', id)
            // verify required parameter 'memberId' is not null or undefined
            assertParamExists('updateEventAttendee', 'memberId', memberId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('updateEventAttendee', 'body', body)
            const localVarPath = `/events/{id}/attendees/{memberId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"memberId"}}`, encodeURIComponent(String(memberId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EventsApi - functional programming interface
 * @export
 */
export const EventsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EventsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} id 
         * @param {EventStatusChangeBody} eventStatusChangeBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelEvent(id: number, eventStatusChangeBody: EventStatusChangeBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelEvent(id, eventStatusChangeBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {EventCreateBody} eventCreateBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEvent(eventCreateBody: EventCreateBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEvent(eventCreateBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEvent(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEvent(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {number} memberId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEventAttendee(id: number, memberId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEventAttendee(id, memberId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCPVEvents(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CPVEventResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCPVEvents(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEvent(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEvent(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listEventAttendees(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventAttendeeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listEventAttendees(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {EventStatusChangeBody} eventStatusChangeBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publishEvent(id: number, eventStatusChangeBody: EventStatusChangeBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.publishEvent(id, eventStatusChangeBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {EventStatusChangeBody} eventStatusChangeBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rejectEvent(id: number, eventStatusChangeBody: EventStatusChangeBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rejectEvent(id, eventStatusChangeBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {EventStatusChangeBody} eventStatusChangeBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submitEvent(id: number, eventStatusChangeBody: EventStatusChangeBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submitEvent(id, eventStatusChangeBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {EventStatusChangeBody} eventStatusChangeBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uncancelEvent(id: number, eventStatusChangeBody: EventStatusChangeBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uncancelEvent(id, eventStatusChangeBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {EventStatusChangeBody} eventStatusChangeBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unpublishEvent(id: number, eventStatusChangeBody: EventStatusChangeBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unpublishEvent(id, eventStatusChangeBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {EventUpdateBody} eventUpdateBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEvent(id: number, eventUpdateBody: EventUpdateBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEvent(id, eventUpdateBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {number} memberId 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEventAttendee(id: number, memberId: number, body: object, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEventAttendee(id, memberId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EventsApi - factory interface
 * @export
 */
export const EventsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EventsApiFp(configuration)
    return {
        /**
         * 
         * @param {number} id 
         * @param {EventStatusChangeBody} eventStatusChangeBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelEvent(id: number, eventStatusChangeBody: EventStatusChangeBody, options?: any): AxiosPromise<void> {
            return localVarFp.cancelEvent(id, eventStatusChangeBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {EventCreateBody} eventCreateBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEvent(eventCreateBody: EventCreateBody, options?: any): AxiosPromise<EventResponse> {
            return localVarFp.createEvent(eventCreateBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEvent(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteEvent(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {number} memberId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEventAttendee(id: number, memberId: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteEventAttendee(id, memberId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCPVEvents(options?: any): AxiosPromise<Array<CPVEventResponse>> {
            return localVarFp.getCPVEvents(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvent(id: number, options?: any): AxiosPromise<EventResponse> {
            return localVarFp.getEvent(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEventAttendees(id: number, options?: any): AxiosPromise<EventAttendeeResponse> {
            return localVarFp.listEventAttendees(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {EventStatusChangeBody} eventStatusChangeBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publishEvent(id: number, eventStatusChangeBody: EventStatusChangeBody, options?: any): AxiosPromise<void> {
            return localVarFp.publishEvent(id, eventStatusChangeBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {EventStatusChangeBody} eventStatusChangeBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rejectEvent(id: number, eventStatusChangeBody: EventStatusChangeBody, options?: any): AxiosPromise<void> {
            return localVarFp.rejectEvent(id, eventStatusChangeBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {EventStatusChangeBody} eventStatusChangeBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitEvent(id: number, eventStatusChangeBody: EventStatusChangeBody, options?: any): AxiosPromise<void> {
            return localVarFp.submitEvent(id, eventStatusChangeBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {EventStatusChangeBody} eventStatusChangeBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uncancelEvent(id: number, eventStatusChangeBody: EventStatusChangeBody, options?: any): AxiosPromise<void> {
            return localVarFp.uncancelEvent(id, eventStatusChangeBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {EventStatusChangeBody} eventStatusChangeBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unpublishEvent(id: number, eventStatusChangeBody: EventStatusChangeBody, options?: any): AxiosPromise<void> {
            return localVarFp.unpublishEvent(id, eventStatusChangeBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {EventUpdateBody} eventUpdateBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEvent(id: number, eventUpdateBody: EventUpdateBody, options?: any): AxiosPromise<void> {
            return localVarFp.updateEvent(id, eventUpdateBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {number} memberId 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEventAttendee(id: number, memberId: number, body: object, options?: any): AxiosPromise<void> {
            return localVarFp.updateEventAttendee(id, memberId, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EventsApi - object-oriented interface
 * @export
 * @class EventsApi
 * @extends {BaseAPI}
 */
export class EventsApi extends BaseAPI {
    /**
     * 
     * @param {number} id 
     * @param {EventStatusChangeBody} eventStatusChangeBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public cancelEvent(id: number, eventStatusChangeBody: EventStatusChangeBody, options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).cancelEvent(id, eventStatusChangeBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {EventCreateBody} eventCreateBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public createEvent(eventCreateBody: EventCreateBody, options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).createEvent(eventCreateBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public deleteEvent(id: number, options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).deleteEvent(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {number} memberId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public deleteEventAttendee(id: number, memberId: number, options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).deleteEventAttendee(id, memberId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public getCPVEvents(options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).getCPVEvents(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public getEvent(id: number, options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).getEvent(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public listEventAttendees(id: number, options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).listEventAttendees(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {EventStatusChangeBody} eventStatusChangeBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public publishEvent(id: number, eventStatusChangeBody: EventStatusChangeBody, options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).publishEvent(id, eventStatusChangeBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {EventStatusChangeBody} eventStatusChangeBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public rejectEvent(id: number, eventStatusChangeBody: EventStatusChangeBody, options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).rejectEvent(id, eventStatusChangeBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {EventStatusChangeBody} eventStatusChangeBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public submitEvent(id: number, eventStatusChangeBody: EventStatusChangeBody, options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).submitEvent(id, eventStatusChangeBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {EventStatusChangeBody} eventStatusChangeBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public uncancelEvent(id: number, eventStatusChangeBody: EventStatusChangeBody, options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).uncancelEvent(id, eventStatusChangeBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {EventStatusChangeBody} eventStatusChangeBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public unpublishEvent(id: number, eventStatusChangeBody: EventStatusChangeBody, options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).unpublishEvent(id, eventStatusChangeBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {EventUpdateBody} eventUpdateBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public updateEvent(id: number, eventUpdateBody: EventUpdateBody, options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).updateEvent(id, eventUpdateBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {number} memberId 
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public updateEventAttendee(id: number, memberId: number, body: object, options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).updateEventAttendee(id, memberId, body, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MembersApi - axios parameter creator
 * @export
 */
export const MembersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroup: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteGroup', 'id', id)
            const localVarPath = `/groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroup: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getGroup', 'id', id)
            const localVarPath = `/groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMember: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getMember', 'id', id)
            const localVarPath = `/members/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGroups: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMembers: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/members`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroup: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateGroup', 'id', id)
            const localVarPath = `/groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MembersApi - functional programming interface
 * @export
 */
export const MembersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MembersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteGroup(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteGroup(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroup(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGroup(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMember(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MemberResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMember(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listGroups(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GroupResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listGroups(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listMembers(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MemberResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listMembers(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateGroup(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateGroup(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MembersApi - factory interface
 * @export
 */
export const MembersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MembersApiFp(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroup(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteGroup(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroup(id: string, options?: any): AxiosPromise<GroupResponse> {
            return localVarFp.getGroup(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMember(id: number, options?: any): AxiosPromise<MemberResponse> {
            return localVarFp.getMember(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGroups(options?: any): AxiosPromise<Array<GroupResponse>> {
            return localVarFp.listGroups(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMembers(options?: any): AxiosPromise<Array<MemberResponse>> {
            return localVarFp.listMembers(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroup(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.updateGroup(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MembersApi - object-oriented interface
 * @export
 * @class MembersApi
 * @extends {BaseAPI}
 */
export class MembersApi extends BaseAPI {
    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembersApi
     */
    public deleteGroup(id: string, options?: AxiosRequestConfig) {
        return MembersApiFp(this.configuration).deleteGroup(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembersApi
     */
    public getGroup(id: string, options?: AxiosRequestConfig) {
        return MembersApiFp(this.configuration).getGroup(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembersApi
     */
    public getMember(id: number, options?: AxiosRequestConfig) {
        return MembersApiFp(this.configuration).getMember(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembersApi
     */
    public listGroups(options?: AxiosRequestConfig) {
        return MembersApiFp(this.configuration).listGroups(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembersApi
     */
    public listMembers(options?: AxiosRequestConfig) {
        return MembersApiFp(this.configuration).listMembers(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembersApi
     */
    public updateGroup(id: string, options?: AxiosRequestConfig) {
        return MembersApiFp(this.configuration).updateGroup(id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PhotoGalleryApi - axios parameter creator
 * @export
 */
export const PhotoGalleryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPhoto: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/photos`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAlbum: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteAlbum', 'id', id)
            const localVarPath = `/albums/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePhoto: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deletePhoto', 'id', id)
            const localVarPath = `/photos/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlbum: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getAlbum', 'id', id)
            const localVarPath = `/albums/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPhoto: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPhoto', 'id', id)
            const localVarPath = `/photos/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAlbums: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/albums`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPhotos: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/photos`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {AlbumEditBody} albumEditBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAlbum: async (id: number, albumEditBody: AlbumEditBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateAlbum', 'id', id)
            // verify required parameter 'albumEditBody' is not null or undefined
            assertParamExists('updateAlbum', 'albumEditBody', albumEditBody)
            const localVarPath = `/albums/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(albumEditBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {PhotoEditBody} photoEditBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePhoto: async (id: number, photoEditBody: PhotoEditBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updatePhoto', 'id', id)
            // verify required parameter 'photoEditBody' is not null or undefined
            assertParamExists('updatePhoto', 'photoEditBody', photoEditBody)
            const localVarPath = `/photos/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(photoEditBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PhotoGalleryApi - functional programming interface
 * @export
 */
export const PhotoGalleryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PhotoGalleryApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPhoto(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPhoto(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAlbum(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAlbum(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePhoto(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePhoto(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAlbum(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AlbumResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAlbum(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPhoto(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PhotoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPhoto(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAlbums(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AlbumsListResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAlbums(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPhotos(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PhotosListResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPhotos(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {AlbumEditBody} albumEditBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAlbum(id: number, albumEditBody: AlbumEditBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAlbum(id, albumEditBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {PhotoEditBody} photoEditBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePhoto(id: number, photoEditBody: PhotoEditBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePhoto(id, photoEditBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PhotoGalleryApi - factory interface
 * @export
 */
export const PhotoGalleryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PhotoGalleryApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPhoto(options?: any): AxiosPromise<void> {
            return localVarFp.createPhoto(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAlbum(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteAlbum(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePhoto(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.deletePhoto(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlbum(id: number, options?: any): AxiosPromise<AlbumResponse> {
            return localVarFp.getAlbum(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPhoto(id: number, options?: any): AxiosPromise<PhotoResponse> {
            return localVarFp.getPhoto(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAlbums(options?: any): AxiosPromise<Array<AlbumsListResponse>> {
            return localVarFp.listAlbums(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPhotos(options?: any): AxiosPromise<Array<PhotosListResponse>> {
            return localVarFp.listPhotos(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {AlbumEditBody} albumEditBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAlbum(id: number, albumEditBody: AlbumEditBody, options?: any): AxiosPromise<void> {
            return localVarFp.updateAlbum(id, albumEditBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {PhotoEditBody} photoEditBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePhoto(id: number, photoEditBody: PhotoEditBody, options?: any): AxiosPromise<void> {
            return localVarFp.updatePhoto(id, photoEditBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PhotoGalleryApi - object-oriented interface
 * @export
 * @class PhotoGalleryApi
 * @extends {BaseAPI}
 */
export class PhotoGalleryApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PhotoGalleryApi
     */
    public createPhoto(options?: AxiosRequestConfig) {
        return PhotoGalleryApiFp(this.configuration).createPhoto(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PhotoGalleryApi
     */
    public deleteAlbum(id: number, options?: AxiosRequestConfig) {
        return PhotoGalleryApiFp(this.configuration).deleteAlbum(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PhotoGalleryApi
     */
    public deletePhoto(id: number, options?: AxiosRequestConfig) {
        return PhotoGalleryApiFp(this.configuration).deletePhoto(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PhotoGalleryApi
     */
    public getAlbum(id: number, options?: AxiosRequestConfig) {
        return PhotoGalleryApiFp(this.configuration).getAlbum(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PhotoGalleryApi
     */
    public getPhoto(id: number, options?: AxiosRequestConfig) {
        return PhotoGalleryApiFp(this.configuration).getPhoto(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PhotoGalleryApi
     */
    public listAlbums(options?: AxiosRequestConfig) {
        return PhotoGalleryApiFp(this.configuration).listAlbums(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PhotoGalleryApi
     */
    public listPhotos(options?: AxiosRequestConfig) {
        return PhotoGalleryApiFp(this.configuration).listPhotos(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {AlbumEditBody} albumEditBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PhotoGalleryApi
     */
    public updateAlbum(id: number, albumEditBody: AlbumEditBody, options?: AxiosRequestConfig) {
        return PhotoGalleryApiFp(this.configuration).updateAlbum(id, albumEditBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {PhotoEditBody} photoEditBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PhotoGalleryApi
     */
    public updatePhoto(id: number, photoEditBody: PhotoEditBody, options?: AxiosRequestConfig) {
        return PhotoGalleryApiFp(this.configuration).updatePhoto(id, photoEditBody, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {UserCreateBody} userCreateBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser: async (userCreateBody: UserCreateBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userCreateBody' is not null or undefined
            assertParamExists('createUser', 'userCreateBody', userCreateBody)
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userCreateBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteUser', 'id', id)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUser', 'id', id)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        impersonateUser: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('impersonateUser', 'id', id)
            const localVarPath = `/users/{id}/impersonate`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsers: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {UserSetPasswordBody} userSetPasswordBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setUserPassword: async (id: number, userSetPasswordBody: UserSetPasswordBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('setUserPassword', 'id', id)
            // verify required parameter 'userSetPasswordBody' is not null or undefined
            assertParamExists('setUserPassword', 'userSetPasswordBody', userSetPasswordBody)
            const localVarPath = `/users/{id}/password`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userSetPasswordBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {UserUpdateBody} userUpdateBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser: async (id: number, userUpdateBody: UserUpdateBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateUser', 'id', id)
            // verify required parameter 'userUpdateBody' is not null or undefined
            assertParamExists('updateUser', 'userUpdateBody', userUpdateBody)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userUpdateBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {UserCreateBody} userCreateBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUser(userCreateBody: UserCreateBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUser(userCreateBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUser(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUser(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUser(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUser(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async impersonateUser(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.impersonateUser(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUsers(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUsers(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {UserSetPasswordBody} userSetPasswordBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setUserPassword(id: number, userSetPasswordBody: UserSetPasswordBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setUserPassword(id, userSetPasswordBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {UserUpdateBody} userUpdateBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUser(id: number, userUpdateBody: UserUpdateBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUser(id, userUpdateBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * 
         * @param {UserCreateBody} userCreateBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(userCreateBody: UserCreateBody, options?: any): AxiosPromise<UserResponse> {
            return localVarFp.createUser(userCreateBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteUser(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(id: number, options?: any): AxiosPromise<UserResponse> {
            return localVarFp.getUser(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        impersonateUser(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.impersonateUser(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsers(options?: any): AxiosPromise<Array<UserResponse>> {
            return localVarFp.listUsers(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {UserSetPasswordBody} userSetPasswordBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setUserPassword(id: number, userSetPasswordBody: UserSetPasswordBody, options?: any): AxiosPromise<void> {
            return localVarFp.setUserPassword(id, userSetPasswordBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {UserUpdateBody} userUpdateBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(id: number, userUpdateBody: UserUpdateBody, options?: any): AxiosPromise<void> {
            return localVarFp.updateUser(id, userUpdateBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * 
     * @param {UserCreateBody} userCreateBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public createUser(userCreateBody: UserCreateBody, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).createUser(userCreateBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public deleteUser(id: number, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).deleteUser(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUser(id: number, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUser(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public impersonateUser(id: number, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).impersonateUser(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public listUsers(options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).listUsers(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {UserSetPasswordBody} userSetPasswordBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public setUserPassword(id: number, userSetPasswordBody: UserSetPasswordBody, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).setUserPassword(id, userSetPasswordBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {UserUpdateBody} userUpdateBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateUser(id: number, userUpdateBody: UserUpdateBody, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).updateUser(id, userUpdateBody, options).then((request) => request(this.axios, this.basePath));
    }
}


